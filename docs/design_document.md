# PyxelPatch 設計書（日本語）

## 1. 概要
**PyxelPatch** は、Python言語とレトロゲームフレームワーク [Pyxel](https://github.com/kitao/pyxel) を用いて構築する、**ノードベースの音楽＆ビジュアルソフトウェア** です。Cycling '74 の **Max** (Max/MSP) に着想を得ており、複数の **ノード**（アプリケーションのコンポーネント）を組み合わせることで音楽や映像生成を行います。各ノードは独立したウィンドウで動作し、ノード間の通信は **MIDI** メッセージをUDPソケットで送受信することで実現します。

大まかな構成は以下のとおりです。

- **リズムマシン (RhythmNode)**  
  リズム（ドラムパターン）を生成し、かつシステムのマスタークロックとして同期信号（テンポ, 拍, ステップなど）を出力。
- **シンセ (SynthNode)**  
  MIDIノート入力から音声を生成するシンセサイザ。単純な波形合成を Pyxel のサウンド機能で行う。
- **映像ジェネレータ (VideoNode)**  
  MIDIメッセージやリズムにあわせて映像を生成・表示。Pyxelのグラフィック機能を使い、パーティクルなどの簡易ビジュアルを出力。
- **ゲーム (GameNode)**  
  Pyxelを使った簡単なゲーム機能。ユーザ操作やリズムに応じて音楽イベントを発火したり、逆にMIDIノートを受け取ったりする。

これらのノードはそれぞれ独立したウィンドウとして動作し、UDPソケットを介したMIDIメッセージのやり取りで連携します。各ノードは独立したディレクトリ（モジュール）として管理され、共通のインターフェース（基底クラス）を実装することで、**ソフトウェアデザインの一貫性** を保ちます。

## 2. アーキテクチャ

### 2.1 ノードベース構造
各ノードは独立したウィンドウとして動作し、それぞれが独自のPyxelアプリケーションとして実装されます。リズム、シンセ、映像、ゲームなどをそれぞれ個別のフォルダ・スクリプトに分け実装します。

1. **RhythmNode**  
   - リズム（ドラムシーケンス）の生成と再生  
   - 同期信号（MIDIメッセージ）を他ノードに送信してテンポを共有  
   - テンポを可変にし、UIやMIDIでBPMを変更可能  

2. **SynthNode**  
   - MIDIノート入力を受けて音を再生する  
   - PyxelのサウンドAPIを用いて合成音を生成  
   - ボリュームや波形などをMIDI CCでコントロール可能  

3. **VideoNode**  
   - MIDIイベントに反応してビジュアル（パーティクルやフラッシュなど）を描画  
   - リズムからの同期信号により、拍やステップで映像を変化させる  
   - Pyxelの描画機能（`pyxel.rect()`, `pyxel.circ()`等）を利用  

4. **GameNode**  
   - Pyxel上で動作する簡易ゲーム。ユーザのキーボード入力やPyxelの操作を受け付ける  
   - イベント発生時にMIDIノートを生成し、シンセを鳴らしたり、映像を動かしたりできる  
   - ゲームロジック内でリズムやシンセからのイベントを受け、ゲーム難易度や動作を変化させるなども可能  

### 2.2 ノード間通信 (UDP MIDI)
- **MIDI over UDP**: 各ノードはUDPソケットを使用してMIDIメッセージを送受信します。
  - 例: リズムマシンがMIDIノートでドラムを鳴らす。シンセはMIDIノートを受け取り音を再生。
  - 各ノードは特定のポート番号でメッセージを待ち受け
  - JSON形式でMIDIメッセージをシリアライズして送受信
- **OSC**: 拡張としてネットワーク越しに制御したい場合に用いる。  
  - 例: `/pyxelpatch/rhythm/bpm 130` などのアドレスを受け取ってテンポを変更  
  - MIDIと同様にノード間でのやり取り、あるいは外部ソフトウェア(例: TouchDesigner, Processing)との連携に活用  
### 2.3 クラス設計 (共通インターフェース)
以下のような **Node** 基底クラスを定義し、各ノードはこれを継承します。

```python
class Node:
    def __init__(self, name, in_channels=None):
        self.name = name
        self.enabled = True
        self.in_channels = in_channels if in_channels else []

    def on_midi(self, msg):
        """MIDIメッセージを受信した際の処理"""
        pass

    def update(self):
        """毎フレーム実行されるメインロジック"""
        pass

    def draw(self):
        """Pyxelの描画処理"""
        pass
```

### 2.4 ディレクトリ構成
```
pyxelpatch/
  ├── src/
  │    ├── base_node.py      # 基底クラス
  │    ├── midi_utils.py     # MIDI通信ユーティリティ
  │    └── nodes/           # ノードモジュール群
  │         ├── 0001_rhythm/ # リズムノード
  │         │    ├── __init__.py
  │         │    └── rhythm_node.py
  │         └── 0002_synth/  # シンセノード
  │              ├── __init__.py
  │              └── synth_node.py
  ├── setup.py
  └── requirements.txt
```

## 3. 実行方法

各ノードは独立したターミナルで実行します：

```bash
# リズムノード（ポート5000）
python -m src.nodes.0001_rhythm.rhythm_node

# シンセノード（ポート5001）
python -m src.nodes.0002_synth.synth_node
```

## 4. 操作方法

- リズムノード
  - スペースキー: リズム開始/停止
  - 画面下部にパターン表示

- シンセノード
  - Zキー: 音を鳴らす
  - 画面中央に現在の音程を表示

## 5. 今後の拡張
- **ノード増設**: エフェクタ、サンプラー、フィルターなど追加ノードを実装
- **GUI接続管理**: ノード間の接続をGUIで管理できるように
- **外部MIDI対応**: 実際のMIDIデバイスとの連携
- **設定ファイル**: ポート番号やMIDIチャンネルの設定をJSON等で管理

---

# まとめ
本設計書は、**Pyxelを用いたマルチウィンドウ型の音楽・映像アプリケーション** の実装例です。各ノードを独立したウィンドウとして動作させ、UDPソケットを介したMIDIメッセージで連携することで、柔軟な拡張性と独立性を確保しています。
